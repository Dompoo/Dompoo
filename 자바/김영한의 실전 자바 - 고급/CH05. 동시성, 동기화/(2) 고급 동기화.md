# 고급 동기화

- `synchronized`는 다음과 같은 단점이 있다.
  - **BLOCKED** 상태에서 무한정 대기한다.
    - 타임 아웃이나 인터럽트가 없다.
  - 락이 돌아왔을 때 **BLOCKED** 상태의 스레드 중 무엇이 락을 얻을지 알 수 없다.
- **LockSupport**라는 클래스를 통해서 무한 대기를 해결할 수 있다.

## LockSupport

- `park()` : 스레드를 **WAITING** 상태로 바꾼다.
- `unpark(thread)` : **WAITING** 상태의 스레드를 **RUNNABLE** 상태로 바꾼다.
  - `park()`는 스스로 할 수 있지만, `unpark()`는 다른 스레드에서 호출해주어야 하기 때문에, 매개변수가 존재한다.
  - `unpark()` 대신에 `interrupt`를 통해서 깨울 수도 있다. 이 경우 **RUNNABLE**로 바뀌고, 인터럽트 상태가 true가 된다.
- `parkNanos(nanos)` : 스레드를 나노초 동안 **TIMED_WAITING** 상태로 바꾼다.
  - 해당 시간이 지나면 **RUNNABLE**이 된다.

### BLOCKED vs WAITING

- 인터럽트
  - **BLOCKED** 상태는 인터럽트가 걸려도 계속 대기한다. 여전히 **BLOCKED** 상태로 남는다.
  - **WAITING** 상태는 인터럽트가 걸리면 바로 빠져나온다. **RUNNABLE** 상태로 바로 바뀐다.
- 용도
  - **BLOCKED** 상태는 `synchronized` 내부에서 락을 획득할 때 사용된다.
    - 즉, `synchronized` 에서만 사용되는 특수한 대기상태이다.
  - **WAITING** 상태는 여러 메서드 호출 시 나타난다.
    - `Thread.join()`, `Thread.park()`, `Object.wait()`
    - 즉, 범용적으로 사용할 수 있는 대기 상태이다.

## ReentrantLock

- **LockSupport**를 통해서 `synchronized`의 무한 대기를 해결했다.
- 하지만, 이를 잘 사용하기는 어렵다. `park()`와 `unpark()`만으로는 적절하게 락을 걸고, 끝날 때 락을 반납하여 다른 스레드를 깨우는 등의 코드를 작성하기 어렵다.
- 그래서 자바는 `Lock` 인터페이스와 `ReentrantLock` 이라는 구현체를 통해 이를 해결한다.
- 참고로 **ReentrantLock**을 통해 얻는 락은 모니터락과 **BLOCKED** 상태와는 관련없다.
  - 구현체 내부에서 소프트웨어적으로 구현된 락이다.

### 기능

- `void lock()`
  - 락을 획득한다.
  - 다른 스레드가 락을 가지고 있다면 **WAITING** 상태가 된다.
  - **인터럽트에 응답하지 않는다.**
  - 이는 **ReentrantLock** 내부적으로 인터럽트가 걸려서 **RUNNABLE**이 되어도, 다시 순간적으로 **WAITING** 상태로 강제 전환 시키기 때문에 가능한 일이다.
- `void lockInterruptibly()`
  - `lock()`과 비슷하다.
  - 단, **인터럽트에 응답한다.**
- `boolean tryLock()`
  - 락 획득을 시도하고, 획득했다면 true, 실패했다면(다른 스레드가 락 소유) false를 반환한다.
  - 위 두 메서드는 언젠가 무조건 락을 획득하는데에 비해, 이 메서드는 실패할 경우 바로 포기한다.
- `boolean tryLock(long time, TimeUnit unit)`
  - 주어진 시간동안 락 획득을 시도한다.
  - 주어진 시간이 지나도 락을 획득하지 못하면 false를 반환한다.
  - 중간에 인터럽트가 걸리면 예외가 발생하며 락 획득을 포기한다.
- `void unlock()`
  - 락을 해제한다.
  - 락 획득을 대기 중인 스레드들 중 하나가 획득하게 된다.
  - 만약 락을 획득한 스레드가 이를 호출하지 않으면, 예외가 발생한다.
- `Condition newCondition()`
  - **Condition**은 락과 결합되어 사용된다.
  - 스레드가 특정 조건을 기다리거나 신호를 받도록 한다.

### 공정성

- **ReentrantLock**는 공정 모드와 비공정 모드를 선택할 수 있다.

```java
// 비공정 모드 락
private final Lock nonFairLock = new ReentrantLock();
// 공정 모드 락
private final Lock fairLock = new ReentrantLock(true);
```

- 비공정 모드
  - 락을 풀었을 때, 대기중인 스레드중 무작위로 락을 획득한다.
  - 락을 획득하는 속도가 빠르다.
  - 특정 스레드가 장기간 락을 획득하지 못할 수 있다.
- 공정 모드
  - 락을 풀었을 때, 대기 큐에서 먼저 대기한 스레드가 락을 획득한다.
  - 락을 획득하는 속도가 약간 느리다.

### 활용

```java
public class BankAccount {
  private int balance;
  private final Lock lock = new ReentrantLock();
  
  public BankAccountV4(int initialBalance) {
    this.balance = initialBalance;
  }

  public boolean withdraw(int amount) {
    log("거래 시작: " + getClass().getSimpleName());
    lock.lock(); // ReentrantLock 이용하여 lock을 걸기
    try {
      log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);
      if (balance < amount) {
        log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);
        return false;
      }
      log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);
      sleep(1000);
      balance = balance - amount;
      log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);
    } finally {
      lock.unlock(); // ReentrantLock 이용하여 lock 해제
    }
    log("거래 종료");
    return true;
  }

  public int getBalance() {
    lock.lock(); // ReentrantLock 이용하여 lock 걸기
    try {
      return balance;
    } finally {
      lock.unlock(); // ReentrantLock 이용하여 lock 해제
    }
  }
}
```

### 대기 중단

- **ReentrantLock**을 통해 무한정 대기하지 않는 락 기능을 사용할 수 있다. `boolean tryLock(long time, TimeUnit unit)`
- 또는 락을 당장 얻을 수 없다면 그냥 바로 빠져나올 수도 있다. : `boolean tryLock()`
- 이를 활용하면 아래와 같이 깔끔한 코드를 짤 수 있다.

```java
public boolean withdraw(int amount) {
  if (!lock.tryLock()) {
    return false;
  }

  try {
    if (balance < amount) {
    return false;
    }
    sleep(1000);
    balance = balance - amount;
  } finally {
    lock.unlock();
  }
  log("거래 종료");
  return true;
}
```
