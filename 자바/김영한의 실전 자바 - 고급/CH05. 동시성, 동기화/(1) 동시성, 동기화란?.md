# 동시성, 동기화란?

- 멀티스레드 환경에서 가장 주의해야 하는 것은 **공유 자원**이다.
- 공유 자원에 대한 접근을 적절하게 동기화하는 것이 중요하다.
  - 동기화한다는 것은 여러 스레드에서 동일한 내용을 보도록 하는 것이다.
- 예를 들어, 멀티스레드 환경에서 동작하는 은행 계좌 도메인에서, 동시에 동일한 계좌 잔액을 보는 것은 매우 중요하다.
  - 만약 두 스레드에서 동일한 계좌의 잔액을 다르게 본다면? -> 동기화 문제
  - 만약 두 스레드에서 동일한 계좌의 잔액을 동시에 수정하려고 한다면? -> 동시성 문제
    - 이는 `volatile`만으로 해결되지 않을 수 있다.
    - 자바의 각 코드는 atomic 하게 실행되지 않으므로, 조건문을 통과하는 순서에 따라 결과가 달라진다.

## 동시성 문제 예시

- t1, t2가 동일 계좌에서 돈을 출금하려고 한다.
  - 출금양이 잔액보다 많으면 예외가 발생한다.
- t1이 먼저 접근한다. `if(잔액 < 출금양)` 조건문을 통과하고 돈을 출금하기 직전까지 간다.
- t2가 다음에 접근한다. `if(잔액 < 출금양)` 조건문을 통과하고 돈을 출금하기 직전까지 간다.
  - **아직 t1이 출금하지 않았기 때문에 조건문을 문제없이 통과한다.**
- t1에서 돈이 출금 완료된다. 잔액은 이제 출금양보다 적어졌다.
- 하지만 t2에서는 이를 감지하지 못한다. **이미 검증 조건문을 통과했기 때문이다.**
  - 따라서 출금하여 잔액은 마이너스가 된다.
- 또 다른 접근 순서에 따라 결과는 매우매우 달라질 수 있다...
  - 둘다 잔액을 1000원으로 보고 출금액 800원을 뺀 200원을 잔액에 두번 대입한다면 두번 출금했는데 잔액은 200원일 수 있다.

## 어떻게 해결할 것인가?

- **검증**과 **출금**이라는 두 단계를 한번에 한 스레드가 실행해야 한다.
- 이렇게 한번에 한 스레드만이 실행해야 하는 영역을 **임계영역(Critical Section)**이라고 부른다.
- 자바에서는 `synchronized` 키워드를 통해 이를 다룰 수 있다.

```java
@Override
public synchronized boolean withdraw(int amount) {
  if (balance < amount) {
    return false;
  }
  balance = balance - amount;
  return true;
}

@Override
public synchronized int getBalance() {
    return balance;
}
```

- 이렇게 선언하면 두 메서드는 한번에 한 스레드만이 사용할 수 있다.
- 이때 한 스레드가 먼저 사용하고 다른 스레드가 뒤늦게 접근하게 되는데 다른 스레드는 **BLOCKED** 상태에 놓이는 것이다.

## 어떻게 작동하는 것인가?

- 모든 객체 인스턴스는 자신만의 락을 가지고 있는다. (모니터 락)
- `synchronized` 키워드가 붙은 메서드에 진입하려면 해당 인스턴스의 락을 지니고 있어야 한다.
- 한 스레드가 먼저 해당 메서드에 접근하고, 락을 획득한 후 메서드를 실행한다.
- 중간에 다른 스레드가 해당 메서드에 접근하지만, 락을 이미 다른 스레드가 획득했기 때문에 얻을 수 없다.
- 따라서 다른 스레드는 **RUNNABLE** -> **BLOCKED**로 상태가 바뀌게 되며, 대기하게 된다.
  - 락을 획득하기 전까지는 무한정 대기한다.
- 처음 스레드는 메서드를 다 실행한 후 락을 반납한다.
- 다른 스레드는 자동으로 락을 획득하고 **RUNNABLE** 상태로 다시 돌아오고, 코드가 실행된다.
  - 이때, 락을 누가 획득할지는 당연히 알 수 없다.

### 메모리 가시성

- `synchronized` 블록에 진입할 때, 최신값을 메인메모리에서 읽어와야 한다.
- `synchronized` 블록에서 나올 때, 현잭밧을 메인메모리에 플러시해야 한다.
- 따라서 `volatile` 같은 키워드 필요없이 메모리 가시성 문제가 해결된다.
- JMM 참고!

### synchronized 코드 블럭

- `synchronized`는 한번에 하나의 스레드만이 접근할 수 있기 때문에 원자성을 보장받지만, 때문에 느리다.
- 따라서 적절한 부분에만 한정하여 적용하는 것이 필요하다.
- 이를 위하여 메서드 단위가 아니라, 코드 블럭 단위로 `synchronized`를 적용할 수 있다.

```java
public boolean withdraw(int amount) {
  log("거래 시작: " + getClass().getSimpleName());
  synchronized (this) {
    log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);
    if (balance < amount) {
      log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);
      return false;
    }
    log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);
    sleep(1000);
    balance = balance - amount;
    log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);
  }
  log("거래 종료");
  return true;
}

@Override
public synchronized int getBalance() {
  return balance;
}
```

- 이렇게 필요한 부분을 선정하고, 그 부분에 대해서만 적용하려는 노력이 필요하다.
