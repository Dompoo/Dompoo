# 스레드의 대기

## synchronized 대기

### 모니터 락 획득 대기

- **synchronized**블록으로 들어갈 때 모니터 락을 이미 다른 스레드가 가진 경우, **BLOCKED** 상태로 대기한다.
  - 여기서 대기하는 곳을 **락 대기 집합**이라고 부른다.
- 다른 스레드가 **synchronized**를 빠져나오면 대기가 풀리며 모니터 락 획득을 시도한다.

### wait() 대기

- `Object.wait()`을 호출하면 실행 중간에 **WAITING** 상태로 대기한다.
  - 이때 모니터 락은 잠시 반납한다.
  - 여기서 대기하는 곳을 **스레드 대기 집합**이라고 부른다.
- 다른 스레드가 `Object.notify()`를 호출하면 빠져나갈 수 있다.

### 두 대기 상태의 작동

- 자바의 모든 객체 인스턴스는 임계 영역을 다루기 위하여 아래 3가지 요소를 가진다.
  - 모니터 락
  - 모니터 락 대기 집합
  - 스레드 대기 집합
- 이 3가지 요소는 맞물려 동작한다.
  1. `synchronized`를 사용한 임계 영역에 들어가기 위해서는 모니터 락이 필요하다.
  2. 모니터 락이 없으면 락 대기 집합으로 들어가서 **BLOCKED** 상태로 대기한다.
  3. 모니터 락을 반납하면 락 대기 잡합의 스레드 중 하나가 모니터 락을 획득하고 **RUNNABLE**이 된다.
  4. `wait()`을 호출하기 위해서는 실행되어야 하므로 모니터 락이 반드시 필요하다.
  5. 스레드 대기 집합에 들어가면 모니터 락을 반납한다.
  6. 스레드가 `notify()`를 호출하면 스레드 대기 집합의 스레드 중 하나가 모니터 락 획득을 시도한다.
     - 모니터 락을 획득하면 임계 영역을 수행한다.
     - 모니터 락을 획득하지 못하면 다시 락 대기 집합에 들어가서 **BLOCKED** 상태로 대기한다.

## Lock 대기

- **synchronized**와 크게 다르지 않다. 동일한 개념들이 반복되어 등장한다.

### 락 획득 대기

- **ReentrantLock**의 대기 큐에서 관리한다.
- `lock.lock()`을 호출 했을 때 락이 없으면 대기한다.
  - **WAITING** 상태로 대기한다.
- 다른 스레드가 `lock.unlock()`을 호출 했을 때 대기가 풀리며 락 획득을 시도한다.

### await() 대기

- `condition.await()`를 호출 했을 때, **Condition** 객체의 스레드 대기 공간에서 관리된다.
  - **WAITING** 상태로 대기한다.
- 다른 스레드가 `condition.signal()`을 호출 했을 때 condition 객체의 스레드 대기 공간에서 빠져나간다.
