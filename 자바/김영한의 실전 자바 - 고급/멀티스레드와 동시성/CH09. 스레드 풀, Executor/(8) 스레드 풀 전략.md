# 스레드 풀 전략

- `corePoolSize`, `maximumPoolSize` 등을 조합하여 나에게 맞는 스레드 풀 전략을 선택적으로 사용할 수 있다.
- 자바는 3가지의 대표적인 기본 전략을 제공한다.

## 단일 스레드 풀 전략

```java
Executors.newSingleThreadExecutor();
new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());
```

- 스레드를 1개만 사용한다.
- 블로킹큐의 용량 제한이 없다.
- 간단한 테스트 용도 정도로 사용한다.

## 고정 스레드 풀 전략

```java
Executors.newFixedThreadPool(N);
new ThreadPoolExecutor(N, N, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>());
```

- 초과 스레드를 생성하지 않는다.
- 블로킹큐의 용량 제한이 없다.
- 스레드 수가 고정되어 있기 때문에, 어느정도 리소스 사용이 예측되는 전략이다.
- 가장 안정적으로 서비스를 운영할 수 있다.
  - 단, 사용자가 점진적으로 늘어나면서 점점 느려질 수 있다.
  - 또한 사용자가 폭증하는 경우 **리소스 사용은 적으나, 스레드 개수 부족 때문에 사용자 경험이 안좋을 수 있다.**
- 따라서 처음부터 적절히 리소스 사용을 고려하여 스레드 개수를 잡는 것이 중요하다.

## 캐시 스레드 풀 전략

```java
Executors.newCachedThreadPool();
new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<>());
```

- 기본 스레드를 사용하지 않고, 60초 생존 주기의 초과 스레드만을 사용하는 전략이다.
  - 초과 스레드의 개수에는 제한이 없다.
- `SynchronousQueue`는 버퍼가 없는 대신, 생산자와 소비자를 동기화하여 스레드끼리 직접 데이터를 주고받을 수 있도록 하는 블로킹큐이다.
- 매우 빠르고 매우 유연한 전략이다.
- 메모리 자원만 허용한다면 시스템의 자원을 최대한 사용할 수 있다.
- 작업의 요청 개수만큼 스레드의 수가 증가하고 감소한다.

## 사용자 정의 스레드 풀 전략

```java
new ThreadPoolExecutor(100, 200, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1000));
// 기본 스레드 100개
// 긴급 상황시 초과 스레드 100개 추가 투여 (60초 생존)
// 블로킹큐 대기 작업 1000개 제한 <- 1000개 이상 대기하면 긴급 상황이라고 가정.
```

- 일반적인 상황에서는 기본 스레드만 사용하다가, 긴급 상황에서는 초과 스레드를 사용하다가, 긴급 대응도 어렵다면 요청을 거절하는 등, 좀 더 세분화된 전략이 필요할 수 있다.
- 처리 가능한 수준의 요청만 처리하고, 나머지는 거절할 필요가 있다.
  - 어떤 경우에도 시스템이 다운되면 안된다.
- 위 예제에서는
  - 0~1100개 : 정상 상황
  - 1101~1200개 : 긴급 상황
  - 1201~ : 응급 상황, 요청 거절 필요!
- 재밌는 것은, 긴급 상황에 의해 스레드가 100개에서 200개로 늘어나므로, 작업이 1100개일때보다 1200개일때 전체 작업은 더 빨리 끝날 수 있다는 것이다.
