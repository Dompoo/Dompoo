# CAS 연산

- 락을 사용하여 동시성 문제를 해결할 수 있지만 아쉬운 부분이 있다.
- **속도가 너무 느리다.**
  - 락이 있는지 확인한다.
  - 락을 획득하고 임계 영역에 들어간다.
  - 작업을 수행한다.
  - 락을 반납한다.
- 스레드가 많다면 위 작업이 계속해서 반복적으로 실행될 것이다.
- 때문에 락을 걸지 않고 원자적 연산을 수행할 필요가 있었는데, 이를 **CAS** 연산이라고 한다. (Compare And Swap/Set)
  - **CAS** 연산은 락을 완전히 대체하지는 못한다.
  - 거의 모든 영역에 기본적으로 락을 사용한다.

## AtomicInteger의 CAS

`atomicInteger.compareAndSet(25, 10);`

- 메서드명을 보면 너무나 두개의 연산 같다.
  - 메인메모리의 값을 확인한다.
  - 기대하는 값과 같다면 원하는 값으로 변경한다.
- 하지만 **CPU 하드웨어적으로 지원**되어 원자적으로 실행된다.
  - CPU는 두 과정 사이에 다른 스레드가 값을 변경할 수 없도록 잠깐 막는다.
  - 자바의 **CAS**는 이런 하드웨어적인 지원을 연결하는 인터페이스일 뿐이다.

## AtomicInteger 내부에서 CAS 연산의 활용

```java
// 실제 코드는 아니다. 비슷하게 만든 수도 코드이다.
public static int incrementAndGet(AtomicInteger atomicInteger) {
    int getValue;
    boolean result;
    do {
        getValue = atomicInteger.get();
        // 중간에 다른 스레드가 값을 바꾸게 되면 false이기 때문에, 다시 시도하게 된다.
        // 결국 이 메서드는 여러번 시도하더라도 무조건 성공하는 +1 연산이 된다.
        result = atomicInteger.compareAndSet(getValue, getValue + 1);
    } while (!result)
    return getValue + 1;
}
```

- 위와 같이 **CAS** 연산을 통하여 이전에 가져온 값과 동일하다면 업데이트, 아니라면 재시도한다.
- 이를 통해 무조건 성공하는 `++` 연산을 만들 수 있다.
- AtomicInteger의 다른 메서드들도 이와 비슷하게 **CAS**를 통해서 구현되어 있다.
- 정리하자면 **CAS는 락을 사용하지 않고, 재시도하는 방식을 활용하여 대기 시간을 줄인다.**
  - 만약 여러 스레드가 자주 동시에 동일한 변수의 값을 변경하려고 한다면 **CAS**가 자주 실패하게 될 것이다.

## 락 vs CAS

- 락 방식
  - **비관적 접근법**이다. (충돌 가능성을 염두에 두고, 안전하게 접근한다.)
  - 다른 스레드의 접근을 막는다. (특정 부분에 대하여 싱글스레드처럼 작동한다.)
- CAS 방식
  - **낙관적 접근법**이다. (일단 접근하고, 충돌하는지 확인한다.)
  - 다른 스레드의 접근을 막지 않는다. (진정하게 멀티스레드로 작동한다.)
  - 만약 충돌이 발생하면 그때 재시도한다.

### 언제 무엇을 사용할까?

- 간단한 연산들은 충돌이 발생하기 전에 연산이 끝나기 때문에 CAS를 사용해도 충돌이 적다.
- 단, 연산이 복잡해질수록 충돌이 자주 발생하기 때문에 락을 사용하는 것이 좋다.
