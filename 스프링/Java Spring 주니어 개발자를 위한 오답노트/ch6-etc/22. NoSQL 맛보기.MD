## DB 사용의 다른 여러 목적들
- 중앙화된 캐시가 필요한 경우
  - 빠르게 변하는 경우 RDB write 성능 문제가 생길 수 있다.
  - 이럴 경우에는 **Redis**를 사용하기도 한다.
- 메시지 큐가 필요한 경우
  - 통신시에 데이터가 유실되지 않도록 큐에 넣고 싶을 수 있다.
  - **kafka**, **rebitMQ** 등이 사용된다.
- 검색이 필요한 경우
  - **Elasticsearch**을 사용한다.
- 시계열 차트를 그려야 하는 경우
  - **influxdb** 등을 사용한다.

## Key-value DB
- DB자체가 큰 Map으로 구성되어있는 형태이다.
- Redis가 대표적이다.
  - 싱글 스레드이다. -> 성능이 문제되지는 않는다. 오히려 병렬처리로부터 자유롭고 고성능이다.
  - 확장 전략을 샤딩이나 클러스트 모드를 사용한다.
    - 샤딩 : 데이터를 여러 Redis 인스턴스에 나눠 저장 -> 저장 용량 확장
    - 클러스터모드 : Redis 내장 기능으로, 데이터 분산과 고가용성을 제공
  - KEYS를 사용하지 말자.
    - 전체 키 공간을 스캔하여 지정된 패턴에 맞는 키를 검색한다.
    - DB 크기가 커질수록 속도가 기하급수적으로 느려진다.
    - 싱글스레드로 작동하므로, 다른 작업이 블로킹되므로 전체 성능이 크게 저하된다.

## Wide column DB
- 대량의 데이터를 저장하는데 특화된 DB
- RDB와 다르게 릴레이션(테이블간 관계)이 없어 Write 성능이 빠르다.
- Casandra가 대표적이다.
  - Consistent hashing
    - 해시함수값을 노드별로 분담하여 저장
    - 노드도 vnode로 나누어 분담하여 저장한다.
    - 이를 나누는 partition key가 중요하다.
  - 쓰기 성능이 매우 빠르다.

## Document DB
- Json과 비슷한 형태의 데이터를 저장한다.
- MongoDB, Elasticsearch등이 대표적이다.
- ES
  - 검색에 사용할 수 있는 DB이다.
  - 전문 검색에 탁월한 성능을 가진다.
  - 클러스터에 인덱스가 너무 많아지면 문제가 생기기 쉽다.
  - update가 없다. (삭제하고 새로 만드는 방식으로 동작)
  - 통계 내기에 유용하다.
- MongoDB
  - 트랜잭션 지원
  - 전문 검색 지원

## Graph DB
- 관계망을 표현할 때 주로 사용
- 소셜관계망, 구독 모델등에 사용하기 매우 좋다.

## Message system
- 데이터를 적재하는 것이 목적이 아니라 DB는 아니다.
- 하나의 거대한 큐처럼 동작한다.
- kafka나 RabbitMQ를 많이 쓴다.
- MQ
  1. producer가 data를 exchange에 퍼블리시
  2. broker가 data를 바인딩된 큐로 라우팅
  - Exchange타입에 따라 작동 방식이 다르다.
- kafaka
  1. producer가 data를 topic에 퍼블리시
  2. topic은 data의 key값에 따라 특정 파티션에 data를 보낸다.
  3. 파티션을 바라보고 있는 consumer들이 데이터를 들고와서 처리한다.
