# 스프링부트 빌드와 배포

- `./gradlew clean build`를 통해서 빌드하면 jar 파일이 생성된다.
- 언뜻보면 기존에 우리가 만들었던 FatJar와 비슷해보인다.
- 하지만 class 파일이 아니라, `BOOT-INF/lib` 아래에 **라이브러리들이 jar 파일로 구성**되어 있다.

## 폴더 구조

- `META-INF/MANIFEST.MF` : 메인 메서드 지정
- `org/springframework/boot/loader/JarLauncher.class` : 부트 시작 지점, 뒤에 설명
- `BOOT-INF/classes` : 우리가 개발한 class 파일과 리소스 파일
- `BOOT-INF/lib` : 외부 라이브러리 jar 파일

## 실행 가능 Jar

- FatJar는 다음과 같은 단점이 존재했다.
    - 어떤 라이브러리가 포함되어있는지 확인하기 어렵다.
    - 같은 파일명이 충돌된다.
- 스프링부트는 해당 문제를 해결하기 위해 jar 내부에 jar를 포함할 수 있는 특별한 구조의 jar를 만들었다.
    - 이것을 **실행 가능 jar**라고 부른다.
    - **자바 표준이 아니라 스프링부트에서 새로 정의한 것이다.**

### 어떻게 작동하는가?

- `MANIFEST.MF`에 보면, Main 클래스가 `JarLauncher`로 지정되어 있는 것을 확인할 수 있다.
    - 스프링부트가 빌드 시에 임의로 시작 지점을 `JarLauncher`로 지정한다.
- `JarLauncher`는 다른 라이브러리들의 jar 파일들을 읽고, 특별한 구조에 맞게 클래스 정보도 읽어들인다.
- 해당 작업들이 종료된 후에 우리가 정의한 Main 클래스를 실행한다.
- 즉, 스프링부트는 엔트리포인트를 자신으로 향하게 하여, FatJar의 한계를 뛰어넘었다.
- 참고로 IDE에서 실행할 때에는 내가 만든 Main 클래스를 실행시켜도 IDE가 알아서 의존성들을 가져와주기 때문에 바로 실행된다.

## War, Jar, FatJar, 실행 가능 Jar 비교

- War
    - 외장 서버를 사용할 때 쓴다.
    - 외장 서버의 특정 위치에 해당 War 파일을 위치하게 하여 작동한다.
    - 따로 작동할 수 없으며, 오직 서버 위에서 작동한다.
- Jar
    - 자바를 실행시키는 독립적인 빌드 결과이다.
    - 다른 Jar를 포함할 수 없다.
    - 따라서 외부 라이브러리를 포함할 수 없다.
- FatJar
    - Jar의 한계를 극복하기 위해, 외부 라이브러리(톰캣 포함)를 class 파일로 풀어서 가지고 있는다.
    - FatJar를 통해 톰캣도 내장하여 실행될 수 있다.
    - 단, 라이브러리 의존 관계 확인이 어렵고, 파일명 충돌이 발생한다는 단점이 있다.
- 실행 가능 Jar
    - 스프링부트 독자 규격이다. (기존 Jar의 형식에 추가 작업이 들어갔다.)
    - 외부 라이브러리들을 Jar 파일로 따로 가지고 있는다.
    - Main 클래스를 스프링부트(JarLauncher)로 향하게 하고, JarLauncher가 실행에 필요한 jar파일들을 읽어들인다. 그 후에 내가 개발한 Main 클래스를 실행한다.
    - 덕분에 FatJar의 단점을 해소하고도 내장 톰캣을 가질 수 있다.