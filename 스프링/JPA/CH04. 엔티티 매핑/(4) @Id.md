# @Id

- 기본키 매핑에는 `@Id`를 사용한다.
- 이때, 기본키를 직접 할당하거나 자동 할당할 수 있는 등 여러가지 방법이 존재한다.

## 직접 할당

- `persist()` 하기 전에 기본키로 매핑된 필드에 값을 넣어주면 된다.

## 자동 할당

- 자동 할당을 위해서는 `@GenertatedValue`를 추가해주면 된다.
- 이 애노테이션에는 어떤 전략을 선택할지 정할 수 있는데, 기본은 IDENTITY 이다.

### IDENTITY

- DB에 기본키 생성을 위임한다. (AUTO_INCREAMENT 기능 등)
- 따라서 DB에 저장한 후에야 기본키를 알 수 있다.
- 최적화 : 그렇다면 DB에 INSERT 쿼리 1번, SELECT 쿼리 1번 해서 기본키를 가져오나 싶지만, JDBC 스펙에서 최적화되어 1쿼리로 저장과 기본키를 가져온다.
- **쓰기 지연 비동작** : 영속 상태가 되기 위해서는 기본키 값이 있어야 한다.(1차 캐시 저장시 필요) IDENTITY 전략에서는 DB에 저장해야 기본키를 알 수 있으므로 `persist()`시 곧바로 INSERT 쿼리가 호출된다. 즉, 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.

### SEQUENCE

- 유일한 값을 순서대로 생성하는 DB 시퀀스를 활용한다.
- `persist()`시 DB에 SELECT 하여 기본키값을 찾아내고, 영속성 컨텍스트에 저장된다. 즉 쓰기 지연이 정상적으로 동작한다.
- 엔티티 별로 시퀀스를 따로 관리하고 싶다면 `@SequenceGenerator`를 사용한다.
  - allocationSize를 정할 수 있는데, 이는 최적화와 관련된다. 50이 기본값이며, 이때 1 -> 51 으로 시퀀스가 증가한다. 이 덕분에 JPA 내부적으로 SELECT를 1번만 진행하고, 1~50까지의 기본키는 내부적으로 할당하는 최적화가 이루어진다.

### TABLE

- 시퀀스와 비슷하나, DB가 시퀀스를 지원하지 않는 경우 테이블을 통해 시퀀스를 흉내내는 전략이다.
- `@TableGenerator`를 통해서 테이블을 지정할 수 있다.
- allocationSize를 통한 최적화가 시퀀스와 동일하게 이루어진다.

### AUTO

- 사용하는 DB 방언에 따라 위 전략들 중에 하나를 유연하게 자동으로 선택한다.
- 개발초기단계나 프로토타입등에서 활용하고, 서비스가 성장하면 위 전략들 중 하나를 선택하자.
