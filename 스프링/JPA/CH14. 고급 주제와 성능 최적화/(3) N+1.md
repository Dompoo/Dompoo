# N+1 문제

- N+1 문제란 예상했던 1개의 쿼리에 예상치못한 N개의 쿼리가 추가되는 성능 문제점이다.
- 즉시 로딩이든 지연 로딩이든 항상 발생할 수 있다.
  - 즉시 로딩 : JPQL을 사용하면 최적화없이 쿼리가 그대로 나간다. `select m from Member m` 같은 JPQL이 나가고 나서(1), 해당 Member와 즉시 로딩 연관관계를 가진 Order를 불러들이는 SQL이 N개 나갈 수 있다.
  - 지연 로딩 : JPQL을 실행할 때는 문제가 발생하지 않는다. 하지만, `members.get(0).getOrders().getSize()` 같이 지연 로딩을 동작시키는 메서드를 호출하면 예상치 못한 추가적인 SQL이 나갈 수 있다.

## N+1 문제 해결 : 페치 조인

- 즉시/지연 로딩 모두 JPQL이 문제였다.
  - 이는 하이버네이트가 최적화하도록(조인하도록) 하지 못하기 때문이다.
- 따라서 JPQL에서부터 조인을 활용하여 불러들이면 해당 문제가 발생하지 않는다.
- `select m from Member m join fetch m.orders`

## N+1 문제 해결 : @BatchSize / @Fetch(FetchMode.SUBSELECT)

- 가장 보편적으로 쓰이고 권장되는 것은 페치 조인이지만(추가 쿼리를 없앤다), 추가 쿼리를 최대한 억제하는 방법도 있다.
- `@BatchSize` 를 통해서 추가 쿼리를 보낼 때 N개가 아니라, 필요할 때마다 배치크기만큼 자른 분량으로 쿼리할 수 있다.
- `@Fetch(FetchMode.SUBSELECT)` 를 통해서 추가 쿼리를 보낼 때 sub select를 통해 1쿼리로 해겨할 수 있다.

## 결론

- 즉시 로딩을 사용하지 말고 지연 로딩을 사용한다.
- 지연 로딩에 의한 N+1 문제가 발생되는 지점에 페치 조인을 도입한다.
