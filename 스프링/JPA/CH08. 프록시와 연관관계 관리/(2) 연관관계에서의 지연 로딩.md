# 연관관계에서의 지연 로딩

- `Member` 엔티티가 `Team` 엔티티와 N:1 관계를 맺고, 멤버 변수로 가지고 있다고 해보자.
- 이때 `Member` 엔티티를 조회할 때 `Team` 엔티티를 같이 조회하는 것이 좋을까? 아니면 지연 로딩을 통해 실제 사용할 때 조회하는 것이 좋을까?
- JPA는 두 방법을 모두 제공한다.
  - `fetch = FetchType.LAZY` : **지연 로딩**
  - `fetch = FetchType.EAGER` : **즉시 로딩**

```java
@Entity
public class Member {
    //...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id")
    private Team team;
}
```

- 즉시 로딩을 활용할 경우 조회시 **조인** 쿼리로 `Team`도 같이 조회하게 된다.
  - `@ManyToOne`을 보면 optional하다. 따라서 외부 조인된다.
  - 만약 `optional = false`일 경우 내부 조인되며, **성능 최적화된다.**
  - N:1, optional false 관계에서만 작동하는 최적화이다.
- 지연 로딩을 활용할 경우 나중에 team에 접근할 때에 쿼리가 추가로 나간다.

## 언제 무엇을 사용할까?

- 정답은 없다. 거의 항상 두 엔티티가 동시에 사용되면 즉시 로딩을, 그런 것이 아니라면 지연 로딩을 선택하자.
- 예를 들어, Member에 Team과 Locker와 Setting이 연관되어 있을 때, Team은 거의 항상 같이 사용되지만, Locker와 Setting은 그렇지 않다고 하자.
- 그럴 경우에는 Team을 즉시 로딩, 나머지를 지연 로딩을 통해서 쿼리하도록 설정하면 된다.

## 기본 전략

- 기본적으로 연관된 엔티티가 1개면 즉시 로딩, 연관된 엔티티가 여러개면 지연 로딩한다.
- 추천되는 방법은 모두 지연 로딩을 하고, 필요한 경우에만 구분하여 즉시 로딩을 적용시키는 것이다.
- 또한 컬렉션을 2개 이상 즉시 로딩하는 것은 권장되지 않는다. : 외부 조인을 하기 때문에 컬렉션의 사이즈가 N개면 결과가 N이 된다. 컬렉션이 2개 이상이면 N * M 이 되면서 급격히 크기가 커진다.
