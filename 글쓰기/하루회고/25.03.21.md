## 프롤로그

### SOLID 원칙 각각을 설명하고 이를 설계에 적용하는 방법

SRP : 하나의 객체에는 하나의 책임만이 할당되어야 한다는 규칙이다. 이 규칙은 사실 매우 모순적인데, '하나의 책임'이 무슨 뜻인지 모호하기 때문이다. 사람이 정의하는 하나가 다르기 때문에, 따라서 나는 해당 객체가 어떤 책임을 지는지 마음속으로 정의하고, 그 책임에 맞는 기능들만을 수행하도록 해야 한다.

OCP : 기능 추가시 변경하지 말고 코드 추가만이 있어야 한다는 규칙이다. 이는 특히 앞으로 변동될 가능성이 있는 부분에 뒤에 소개될 DIP를 적용하여, 유연하게 유지하는 것이 많이 도움이 된다. 예를 들어, 장기 미션에서는 장기 보드를 init하는 기능이 추후에 DB로 수정될 가능성이 있어서 이 부분을 유연하게 설계하면 좋다.

LSP : 내가 제일 약한 부분이기도 한데, 하위 타입 객체는 상위 타입 객체에서 가능한 모든 행위를 수행할 수 있어야 한다는 것이다. 이러면 상위 타입 객체를 하위 타입으로 수정해도 정상적으로 작동할 수 있게 된다. 이는 `is-a` 관계가 잘 성립하는지 의심하여 달성할 수 있다.

ISP : 가장 쉬운 규칙이라고 생각하는데, 자신이 사용하는 메서드만을 구현(의존)해야 한다는 것이다. 인터페이스가 커지다보면 해당 인터페이스를 모두 구현하면 사용하지 않는 메서드도 구현해야 하는 상황이 생기는데, 그럴 때 인터페이스를 여러개로 분리하여 모두 구현하도록 하면 된다.

DIP : 내가 제일 좋아하는 규칙이다. 구체화된 클래스에 의존하면 변경에 취약해지기 때문에, 좀 더 추상화된 대상에 의존해야 한다는 규칙이며, 예를 들어 `PieceInitializer`에 의존하고 이를 구현하는 `StaticPieceInitializer`를 만들면 된다. 이러면 추후에 수정이 생겨도 구현체만 바꿔끼면 되므로 매우 유연해질 수 있다.

### 클린 코드의 핵심 원칙(가독성, DRY, SRP)는 무엇인가?

가독성 : 코드가 이해하기 쉽고, 의도가 명확하게 전달되어야 한다는 것이다. 좋은 변수명/메서드명을 사용하고 일관된 코드 스타일을 유지하여 달성할 수 있고, 나는 이를 위해 `editorconfig` 를 적극 사용중이다.

DRY : 중복된 코드를 제거하라는 말이다. 내가 제일 싫어하는 말이기도 한데, 중복되면 무조건 제거할 필요는 없다고 생각한다. 섣부른 리팩터링은 더 큰 관점의 리팩터링을 막는다. 충분히 코드를 오래 작성하고, 그래도 앞으로도 반복될 것 같은 코드에만 적용하는 것이 좋다.

SRP : 하나의 객체는 하나의 책임만을 지녀야 한다는 의미이며, 해당 코드의 변경 포인트를 고민해보면 이해하기 쉬운데, 만약 A와 B라는 두 사람이 다른 이유로 코드를 수정하려고 한다면, 그 수정 포인트는 겹치면 안된다. SRP를 잘 지키지 못하는 순간 유지보수가 급격하게 어려워지는 문제점이 있다.

### 메서드와 변수의 네이밍에서 클린 코드를 적용하는 방법

의도를 명확하게 표현해야 한다. `int i` 같은걸 사용하면 안되지만, 매우 이해하기 명확한 상황에서는 사용해도 될 수 있다. 또한 축약어 사용을 지양해야 한다.
