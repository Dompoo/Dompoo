- 이더리움은 `탈중앙화 서비스`를 만드는데 사용된다.
- `Smart Contract`를 베이스로 작동한다.
	- `Smart Contract`는 **특정 조건을 만족했을 때 자동으로 실행되는 코드**이다.
- 이더리움은 Turing Complete한 기계를 분산하여 저장한다.
- 즉, 세계적으로 분산되어 있는 `Smart Contract`를 실행할 수 있는 컴퓨터 인프라라고 볼 수 있다.
# Bitcoin VS Ethereum
### 공통점
- 둘 다 참여자들을 잇는 P2P 네트워크이다.
- 서명이나 해쉬 같은 암호화 기법을 사용한다.
- 디지털화폐를 사용한다.
### 차이점
- 이더리움의 목적은 지불 시스템이 아니다.
- 이더리움의 화폐인 이더는 이더리움이라는 컴퓨터를 사용하는 비용이다.
- 코드(스크립트) 차이점
	- 비트코인의 코드
		- 지불 조건을 평가하는데에만 사용된다.
		- 안전성과 효율성을 위해 의도적으로 단순하게 설계되었다.
	- 이더리움의 코드
		- 이더리움은 범용적으로 프로그래밍 가능한 블록체인
		- Turing Complete하게 설계되어, 임의 복잡도의 코드를 실행할 수 있다.
	- Turing Complete하면 무한대로 실행될 수 있는 것 아닌가? -> Gas를 통해 해결한다.
- 상태의 차이점
	- 둘 다 **분산된 상태 머신**으로 작동한다.
	- 둘 다 트랜잭션을 통해 상태가 바뀐다.
	- 하지만 무엇을 상태로 갖는지가 매우 다르다.
	- 비트코인의 상태
		- 비트코인의 상태는 해당 비트코인을 누가 소유한지를 추적한다.
		- 즉, 트랜잭션은 비트코인의 소유권 변경을 나타낸다.
	- 이더리움의 상태
		- 일반적인 데이터 저장소의 상태를 추적한다.
		- 키-값 형태로 저장 가능한 임의의 데이터를 저장하고 그 상태 전이를 추적한다.
	- 이더리움의 메모리
		- 따라서 이더리움의 메모리는 코드 뿐만 아니라 데이터를 저장할 수 있다.
		- 트랜잭션이나 `Smart Contract`의 실행 과정에서 이 데이터가 수정될 수 있으며, 이 변화를 블록체인에 기록하며 추적한다.
# Gas
- 이더리움의 코드는 Turing Complete하기 때문에 얼마나 오래, 얼마나 리소스를 많이 잡아먹으며 실행되는지 알 수 없다.
	- 심지어는 영원히 실행될 수 있다.
	- 이 문제를 해결하기 위하여 `Gas`가 도입되었다.
- EVM은 `Smart Contract`를 실행할 때, 각 명령어의 비용(`Gas`)를 세밀하게 추적한다.
	- 각 명령어는 정해진 값의 비용을 가진다.
- 각 트랜잭션에는 `Gas`한도가 정해져 있으며, 만약 이 한도를 초과하면 실행을 중지한다.
- 이를 통해 불필요하게 자원을 낭비하는 `Smart Contract`의 실행을 방지한다.
- `Gas`는 EOA가 트랜잭션에 포함시켜 CA에 넘겨주는 형식이다.
- CA가 `Gas`를 사용하며 트랜잭션을 실행시킨 후, 남은 `Gas`는 EOA에게 다시 돌려준다.
	- 이때, 만약 `Gas`를 다 사용해서 더 이상 실행시키지 못한다면, 해당 상태 변화는 롤백된다.
	- 또한 네트워크 사용료 개념으로 EOA에게 `Gas`를 돌려주지 않는다.
- 트랜잭션 가격을 계산해보자.
	- A가 B에게 1ETH를 보내고 싶다고 하자.
	- A는 `maxPriorityFeePerGas`를 10wei로 설정했다.
	- 현재 이더리움 네트워크에서 `BaseFeePerGas`는 190wei다.
	- 따라서 1가스당 200wei가 필요하다.
	- 이때, 전송이 21000가스가 필요하다고 가정하면, 21000가스 필요 X 200wei = 0.0042ETH이다.
	- A는 1ETH + 0.0042ETH를 내야한다.
	- B는 1ETH를 받는다.
	- 중간 Validator는 21000가스 계산 X 10wei = 0.0021ETH를 받는다.
	- 이때 BaseFee는 소각된다. (21000가스 X 190wei = 0.0039ETH) <- 디플레이션 방지
# DApp
- DApp은 필수적인 두 컴포넌트를 지닌다.
	- 블록체인 상의 `Smart Contract`
	- 해당 `Smart contract`를 사용하기 쉽게 하는 UI
- 여기에 추가적으로 여러 컴포넌트를 가질 수 있다.
	- 탈중앙화 데이터 저장소 플랫폼
	- 탈중앙화 메시지 시스템 플랫폼
	- ...
- `Smart Contract`를 실행하기 위해서는 이더가 필요하므로 사용자 부담이 있다.
- 기존 앱들과는 다르게 일부 노드가 다운되더라도 나머지 노드가 최신 상태를 반영하고 있으므로, 문제 없다.
# 계정
- EOA(Externally Owned Account)
	- 실제 사용자의 계정이다.
	- 개인키에 의해 제어된다.
	- 값 전달(EOA -> EOA), `Smart Contract`호출(EOA -> CA) 등이 가능하다.
	- 실행 체인의 시작점이 될 수 있으므로 능동적이다.
	- 공개키와 비공개키에 의해 제어된다.
		- 비공개키로 해당 계정의 소유권을 주장할 수 있다.
		- 비공개키로 트랜잭션에 서명할 수 있다.
		- 공개키는 비공개키를 통해 생성되며, 서명검증에 사용되며, 계정주소로도 사용된다.
- CA(Contract Account)
	- `Smart Contract`가 실행되는 계정이다.
	- `Smart Contract`의 내용에 따라 해당 계정 내부의 상태데이터가 변화될 수 있다.
	- `Smart Contract`에 의해 트랜잭션을 자동으로 실행하거나, 다른 계정과 상호작용할 수 있다.
	- 혼자 실행될 수 없으므로 수동적이다.
![[Pasted image 20241207220052.png]]
# 계정 상태
- Nonce
	- 각 계정에서 발생한 트랜잭션의 순서 번호이다.
		- EOA의 경우 해당 계정에서 보낸 트랜잭션의 개수
		- CA의 경우 해당 계정에서 생성된 계약의 개수
	- 이를 통해 동일한 Nonce의 트랜잭션은 한번만 실행될 수 있도록 하여, `Replay Attack`등을 막는다.
- Balance : wei 잔고를 나타낸다.
- Storage Root
	- CA의 상태 저장소의 루트 해쉬값이다.
	- CA는 특정 데이터를 저장할 수 있기 때문에 필요하다.
	- CA에서 트랜잭션이 발생하면 이 변경 사항은 `Storage Root`를 통해서 추적된다.
- CodeHash
	- 각 CA에서 실행되는 EVM 코드의 해시값이다.
- World State
	- 이더리움 네트워크의 전역 상태를 나타낸다.
	- 이더리움 네트워크의 모든 계정의 계정 주소 - 계정 상태를 저장한다.
# 트랜잭션
- 트랜잭션에 의해 World State는 다음 State로 넘어가게 된다.
- 이렇게 하기 위해 어떤 노드든 트랜잭션은 BroadCast 할 수 있다.
	- Validator에서 실행된 후 (EVM 실행)
	- 이 실행 결과(상태변화)가 다른 노드로 전파된다.
	- 이 상태변화가 Validated Block에 포함되어야 World State에 기록된다.
- 각 트랜잭션은 아래 3가지 요소를 가지고 있다.
	- from : 트랜잭션에 서명하고 전송한 계정의 주소(무조건 EOA)
	- to : 트랜잭션의 수신 주소
		- EOA일 경우 이더 전송
		- CA일 경우 `Smart Contract` 호출
	- signature : 발신자의 서명
	- nonce : 발신 계정의 트랜잭션 번호(카운터)
	- value : 전송하려는 이더의 양(wei 단위)
	- inputdate : `Smart Contract`에서 args 처럼 사용되는 값
	- gasLimit : 트랜잭션 실행에 사용될 수 있는 최대 가스
	- maxPriorityFeePerGas : 검증자에게 팁으로 제공될 수 있는 가스당 최대 가격
	- maxFeePerGas : 수신자가 최대로 부담할 수 있는 가스당 가격
- 트랜잭션에도 여러 종류가 있다.
	- message calls : `internal transaction`이다. 다른 계정에게 메시지를 보내는 것
	- contract creation : `Smart Contract`를 생성하는 트랜잭션이다.
		- 누군가에게 보내는 것이 아니므로 to가 비어있다.
	- contract run : `Smart Contract`를 실행하는 트랜잭션이다.
		- to는 해당 `Smart Contract`의 주소이다.
- 트랜잭션 제출 후에는 다음과 같은 일들이 벌어진다.
	1. 트랜잭션의 해시가 암호학적으로 생성된다.
	2. 네트워크에 전파되어 대기 중인 트랜잭션 풀에 등록된다.
	3. 검증자가 해당 트랜잭션을 블록에 포함시켜 검증된다.(successful)
	4. 해당 블록이 시간이 지나 justified -> finalized 상태까지 변화된다. (더욱 더 core가 되가는 것)