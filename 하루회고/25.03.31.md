## **주제 1 : 모든 클래스와 메서드에 대해 테스트를 작성해야 하는가?**

### **서브 주제 : 자동 생성한 코드에 대해서 테스트를 작성해야 하는가? (equals, getter 등)**

---

**전부 다 테스트할 필요 없다는 주장**

- 필드를 단순히 조회하거나 비교하기만 하기 때문에 추가 로직이 없어서 테스트할 필요가 없다.
- 다른 테스트로 equals, getter가 테스트가 되는 것 같아서 테스트할 필요가 없다.

**equals는 테스트해야 한다는 주장 (의도를 표현하는 경우)**

- 복잡하기 때문에 테스트해야 한다.
- equals가 전체 필드를 포함하지 않았을 때 테스트했다.
    - 의도를 표현하기 위하여 필요하다.
    - 예를 들어 id가 같으면 같은 객체라는 것을 표현

**질문 : 도메인의 경우 equals는 항상 전체 필드를 포함해야 하는 것은 아닌가?**

- 아니다. 구현하는 사람의 의도에 따라 그럴 수 있다.
- 테스트하기 위해 equals를 재정의하는 것은 다른 부분에 영향이 갈 수 있다고 생각하는 리뷰어가 있었다. 차라리 getter는 어떨까?

### **서브 주제 : 단순 위임하는 객체도 테스트해야 하는가?**

---

> `Participants`의 경우 `Dealer`와 `Players`를 가지고 있고, 위임해서 호출한다. -> 이때 `Participants`도 테스트해야 하는가?
> 

**테스트해야 한다는 주장**

- 테스트를 작성하는 이유 자체가 리팩터링의 사이드이펙트를 막기 위함. -> 단순 위임한다는 개념은 자신만 알고 있는 것이기 때문에 나중을 위하여 작성해야 한다.
- `Participants`도 객체의 관점에서는 다른 역할을 수행한다고 생각한다. 테스트하지 않으면 취약할 수 있다.
- 추후에 변경이 일어났을 때 실수를 할 수 있고, 그것을 방지하기 위해서 테스트해야 한다.
- `Participants`로 묶은 이유가 있을 것이다. 그런 이유, 행위를 검증하는 것이 필요하다. 애초에 그런 테스트를 작성하지 않을 거면 묶을 이유도 없다.
- 클라이언트 입장에서 내부 구현과 상관없이 테스트가 필요할 것이다.

**테스트하지 않아도 된다는 주장**

- 테스트를 명세의 개념으로 작성한다면 필요할 수 있지만, 단순 기능에 대한 테스트라면 하위 테스트에서 이미 검증이 되었기 때문에, 필요없다.
- 현재 상황에서는 기능을 테스트하는 것에 좀 더 가까워서 필요없다.

## **주제 2 : TDD에서 원시값을 사용하여 작성할 것인가? 다른 도메인 객체를 사용하여 작성할 것인가?**

---

**원시값을 사용해야 한다는 주장**

- 처음에는 원시값으로 빠르게 작성하고, 나중에 리팩터링할 때 테스트도 같이 바꾼다.
- 원시값을 쓰는게 리팩터링을 늦추기 때문에 더 좋은 리팩터링을 이끈다.

**상황에 따라 사용해야 한다는 주장**

- TDD를 지금까지는 인아웃으로 해서, 작은 단위로 하기 때문에 테스트를 작성하는 시점에는 필요한 모든 객체가 완성이 되어 있었다. 그래서 자연스럽게 도메인 객체를 사용했다.
    - 반면에 아웃인을 사용했을 경우에는 원시값을 사용할 것 같다.
    - 아웃인과 인아웃을 유동적으로 바꾸기 때문에 상황에 맞는 방법을 사용할 것 같다.
- 디폴트는 원시값이고, 객체를 사용하는 것이 예외적인 케이스라고 생각한다.
    - 객체를 넘기면 의도를 표현할 수 있는가?를 생각하고, 그렇다면 객체를 사용한다.
    - 또는 해당 객체가 불변객체라면 사이드이펙트가 적어지기 때문에 객체를 사용할 확률이 높아진다.
- 근데 TDD 처음부터 다른 도매인 객체나 VO를 사용하기에는 좀 힘들 것 같다.

**질문 : 도메인 객체는 상태만 가지는게 아니라 행위를 할 수 있는 객체인데, 도메인 객체를 넘겨주었을 때의 사이드이펙트도 생각해야 하지 않느냐?**

- 맞다. 하지만 다음과 같은 경우에는 영향이 적어진다.
    - 해당 객체가 불변인 경우
    - 내부 상태를 변화시키는 메서드가 없는 경우

## **주제 3 : JDBC 기반 애플리케이션에 대한 안전한 DB 테스트 환경, 어떻게 구축해야 할까?**

---

> 테스트를 위한 컨테이너를 따로 띄우고, 프로덕션 코드에 쓰이는 테이블 구조를 그대로 복붙해서 테스트했다.
> 
- 인메모리DB 같은 것을 활용하여 JDBC 코드를 테스트했다.
    - MySQL의 경우 커넥션을 가져오는 것 정도만 테스트한다.
    - 컨트롤러 같이 의존성이 필요한 경우는 Fake객체를 사용한다.
- 컨테이너를 하나 더 띄우는 방식으로 DB를 다르게 한다.

**결론 : 레벨2에서 더 공부해보자 ㅋ.ㅋ**