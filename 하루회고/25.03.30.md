# 레벨 1 인터뷰 예상 질문

### Q. 여러 확장성을 고려하는 경우 의도가 잘 드러나지 않으면 오버 엔지어링으로 비쳐질 수 있을 것 같다. 의도하는 것과 오버 엔지니어링은 어떻게 다른가?

### Q. 레벨 1을 진행하면서 본 코드들 중 인상 깊었던 '의도를 드러낸 코드'가 있나?

### Q. 왜 '스스로 생각하고 결정하며 그것을 드러내는 개발자'가 좋은 개발자라고 생각하게 되었는지, 구체적인 계기

저는 객체지향에 정답이 있다고 생각하면서 공부했습니다. 하지만 우테코에 들어오고 나니 어느 수준 이상부터는 거의 모든 결정이 트레이드오프라는 것을 깨달았습니다. 옳은 것은 없고 오직 결정뿐이 남는 상황에서 중요한 것은 결정을 내리고 그 결정에 자신만의 기준이 있는가? 입니다. 예를 들어, **블랙잭을 하는 회사라면, 다른 포커 게임도 추후에 추가될 수 있다.** 라는 결정을 내렸는데, 그 이유는 제가 옛날에 한게임 포커를 해본적이 있는데, 그것 말고도 한게임에서 섯다나 홀덤포커, 블랙잭등의 다른 카지노 게임을 운영하고 있었던게 기억났기 때문입니다.

이런 결정을 내리고 개발한다고 끝이 아니었습니다. 데일리조의 크루들끼리 서로의 코드를 리뷰하는 기회가 있었는데, 다른 크루들은 제 코드가 유연한 것까지는 이해했지만, 왜 유연해야 하는지 이해를 못했습니다. 어떤 크루는 너무 복잡하다고까지 이야기 해주었습니다. 지금 생각해보면 너무 당연한 일인데, 제가 한게임 포커를 했던 경험을 통해 내린 결정을 그들이 이해할 수 없기 때문입니다. 그때는 제 경험을 말했지만, 매번 그럴 수는 없기 때문에 결국 저의 결정이 코드에서 드러나는 것이 중요하다고 생각하게 되었습니다.
그런 결정을 읽는 사람이 이해해야, 즉 코드의 배경을 이해해야 쉽게 읽히고 이해된다고 생각합니다.

### Q. 결정한다는 것은 무엇을 결정하는 것인가?

요구사항에 대한 구현의 결정입니다. 블랙잭 미션을 제가 예로 들었었는데, **블랙잭을 하는 회사라면, 다른 포커 게임도 추후에 추가될 수 있다.**라는 생각을 하고, 그것에 대한 확장성을 열어야 겠다는 결정을 하는 것입니다.
이러한 주체적인 결정을 통해서 미래의 요구사항 변화나 추가에 대비할 수 있게 됩니다.

### Q. 의도를 드러내는 것이 왜 중요한가?

의도를 드러낸다는 것은, 제 생각을 코드에 더 잘 담는다는 의미이기도 합니다. 제 생각이 잘 담긴 코드는 다른 사람이 읽어도 동일한 생각이 들게 하고, 그래서 더 잘 읽히는 코드가 됩니다.
예를 들어, 블랙잭에서 아무 코드를 그냥 읽는 것보다, **다른 포커 게임에 대한 확장성을 고려했다.** 라는 의도를 알고 있는 상태로 코드를 읽는 것은 코드에 대한 이해도가 확실히 좋아집니다.

또 아직 경험해보지는 못했지만, 이런 의도적인 코드가 유지보수성 향상에도 도움을 준다고 믿고 있습니다. 읽는 사람이 코드를 더 잘 이해하기 때문에, 저와 동일한 생각을 가지고 코드를 유지보수할 확률이 높아지기 때문입니다. 유연한 부분은 유연하게 유지될 수 있는 것입니다.

### Q. 의도를 드러내는 또 다른 좋은 방법이 있는가?

좀 더 코드적으로 얘기하면, 이름 짓기가 정말 중요하다고 생각합니다. 또 블랙잭을 예시로 들면, 보통 `Deck` 이라는 이름의 객체에서 카드를 뽑는 크루들이 많았습니다. 사실 이러면 이 덱이 블랙잭을 위한 덱이라는 의도를 표출하기 어렵습니다.
따라서 `Deck` 은 카드를 뽑는 객체로 두고, `BlackjackDeck` 같은 객체에서 블랙잭에 특화된 기능들을 추가하는 방향으로 설계하면 읽는 사람은 `BlackjackDeck`이 블랙잭 게임에 특화된 도메인이라는 것을 쉽게 이해할 수 있습니다.
이외에도 저는 서술적인 이름을 짓는 것을 좋아하는데, 멋지고 대중적인 `Player` 같은 도메인명 보다는, `BettingBlackjackPlayer` 같이 확실히 무슨 기능을 수행하는지 명시해주는 객체명이 도움이 됩니다.

### Q. 평이한 코드와 노력한 코드를 나누는 기준은?

이건 읽는 사람마다 조금씩 편차가 있다고 생각하지만, 누구에게나 통용되는 규칙을 말씀드리자면,
먼저 **객체 수가 많습니다.** 저는 장기 미션에서 위치를 나타내기 위해 `Position` 이라는 객체를 하나 사용했는데, 밍곰이라는 크루는 `Position`, `GungsungPosition`, `NormalPosition` 등으로 위치도 추상화를 했습니다. 이런 객체들을 보면, 굳이 코드를 읽지 않아도 '아, 추후에 궁성을 제외하고도 다른 위치들이 추가될 것을 고려했다.'라는 의도가 느껴지고 그 부분에서 노력한 것이 느껴집니다.
또 다른 특징으로는 해당 부분이 다른 모듈들에 의존하지 않습니다. 서로서로 의존해도 되는 같은 도메인인데도, 굳이 그렇게 의존성을 관리한 것은 추후에도 변경되지 않을 만큼 단단하게 작성했다는 뜻이고, 그만큼 핵심이라는 뜻입니다. 그런 의존성을 보고도 나눌 수 있을 것 같습니다.

### Q. 코드의 킬링포인트를 만드는 방법은?

저는 킬링포인트를 **현재 상황에서는 필요하지 않을 만큼 유연하게** 코드를 작성하여 만듭니다.
예를 들어, 장기 미션에서 궁, 차, 포 등과 같은 기물들이 존재했고, 각 기물들의 움직임이 다르기 때문에 보통 추상클래스를 통해 해결하는 크루들이 많았습니다.
물론 잘 추상화하면 추후에 다른 기물이 추가되거나 수정되더라도 유연하게 대처할 수 있겠지만, 저는 아예 다른 생각을 했습니다.
현재 도메인에 기능을 조금만 추가하면 체스도 둘 수 있고, 일본 장기도, 심지어는 윷놀이도 할 수 있도록 설계하고 싶었습니다. 그래서 공통적으로 모든 게임의 기물들이 **경로를 추가하는 개념**과 **경로를 필터링하는 개념**으로 나뉜다는 것을 포착하여 개발했습니다.

경로를 추가하는 개념으로 같은 기물에 십자로 이동하는 기능을 넣고, 필터링하는 개념으로 다른 기물에 막히는 기능, 아군 기물에서 멈출 수 없는 기능을 넣으면 장기의 차가 됩니다. 여기에 대각선으로 이동하는 기능을 넣으면 체스의 퀸이 됩니다. 오히려 아군 기물에서 멈출 수 없는 기능을 빼면 윷놀이가 될 수도 있겠습니다.
이런 기능들을 동적으로 끼워넣을 수 있도록 설계하여, 같은 `Piece` 도메인 객체가 모든 게임에서 공통적으로 쓰일 수 있는 객체로 만들었습니다.
이런식으로 **현재 상황에서 과한 유연함**이 킬링포인트가 된다고 생각합니다.

### Q. 지금까지 어떠한 진리들을 의심해보았는지, 그 결과는?

저는 우테코에서 **객체지향 생활 체조 원칙**을 지키라고 하는 것을 많이 의심하고 위반했는데요.
예를 들어, `else`를 쓰지 말라고 하는데, 그것이 가독성 때문이라는 것을 알고 현재 코드에서 else 예약어가 정말로 가독성을 해치는지 찾아보았습니다. 물론 그런 부분도 있었지만, else 예약어가 가독성을 더 좋게하는 현상도 보았고 그런 부분은 그냥 두었습니다.
또 같은 맥락에서 `switch`도 사용하지 말라고 하는데, 사실 switch 표현식과 열거형의 조합이 정말 좋습니다. 모든 케이스(열거형 상수)가 작성되지 않았으면 컴파일 오류가 나기도 하기 때문에, 이런 부분에서는 switch를 적극 도입하고 있습니다.
이런 과정들을 통해 객체지향 생활 체조 원칙을 무조건 따라야 하는 원칙이 아니라, 한번쯤 고민해보면 좋을 내용 정도라고 생각하게 되었고, 그 과정에서 어떤 코드가 가독성을 해칠 수 있는지, switch 문과 표현식의 차이점 등을 공부하게 되었고 더 많은 선택지를 가지게 되었습니다.
