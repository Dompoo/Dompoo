# 좋은 객체지향이란?
* 유연하고 변경에 용이한 것.
### 다형성
* 다형성이란 **역할**과 **구현**을 구분하는 것이다.
    * 이래야 역할이 똑같은 여러 구현들을 '갈아끼울 수 있다.'
    * 역할은 인터페이스, 구현은 구현체로 말할 수 있다.
    * 같은 역할만 수행한다면 새로운 구현체를 만들어도(새로운 기능을 추가하는 등) 이를 갈아끼워 제공할 수 있다.
* 가장 중요한 것은 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
* 클라이언트는 내부 구조가 변경되어도, 구현체가 변경되어도, 영향을 받지 않는다.
* 누구가 클라이언트인가? : 작게 보면 객체간, 크게 보면 서버와 클라이언트까지 다형성의 대상이다.
* **주의** : 인터페이스가 깨지면 모든 것이 변경되야 한다. -> 인터페이스 설계에 주의할 필요가 있다.
### SOLID
* **SRP 단일 책임 원칙**
  * 한 클래스는 하나의 책임만 가져야 한다.
  * 기준은 **변경**, 변경이 있을 때 파급효과가 적어야 단일 책임을 가진 것이다.
* **OCP 개방-폐쇄 원칙**
  * 확장에는 열려있으나, 변경에는 닫혀있어야 한다.
  * 다형성을 활용하여 새로운 기능을 추가할 때는 추가만 하도록, 다른 객체를 변경하지 않아도 되도록!
  * OCP를 지키기 위하여 IoC, DI가 사용된다.
  * 내 생각에는 다른 개념을 포함할 수 있는 가장 큰 개념인 것 같다.
* **LSP 리스코프 치환 원칙**
  * 객체는 정확성을 깨뜨리지 않으면서 하위 타입의 다른 인스턴스로 바꿀 수 있어야 한다.
  * 간단히 말해서, 인터페이스를 정확하게 구현하여 다른 구현체로 치환하는 과정이 안전해야 한다는 것이다.
* **ISP 인터페이스 분리 원칙**
  * 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
  * 인터페이스를 나누면 명확해지며, 유연해질 수 있다.
  * SRP와 통용되는 이야기
* **DIP 의존관계 역전 원칙**
  * 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
  * 의존성 주입도 같은 맥락이다.
  * 모든 코드는 인터페이스를 참조하여 여러 구현체가 유연하게 변경될 수 있도록 해야한다.
### 코드 예시
* 안좋은 예
  * MemberRepository repository = new MemoryMemberRepository();
  * 이를 변경하려면
  * //MemberRepository repository = new MemoryMemberRepository();
  MemberRepository repository = new JdbcMemberRepository();
  * 기존 코드가 변경되었다. -> 이거 문제있다!!!
* 그렇다면 어떻게?
  * 다형성만으로는 OCP, DIP를 지킬 수 없다...
  * 스프링은 이를 DI를 통해 **의존관계, 의존성 주입**하여 해결한다. -> 추후에 코드를 통해 학습
### 정리
* 모든 설계에 역할과 구현을 분리해야 한다.
* 이를 통해 유연하게 변경할 수 있게 된다.
* 다형성만으로는 이를 취할 수 없다. 스프링은 DI 컨테이너를 제공하여 이를 해결한다.
* 다만, 무분별한 인터페이스 사용은 추상화비용을 야기한다. 따라서 일단 구체 클래스를 사용하고, 후에 리팩터링을 고려하는 것도 방법이다.