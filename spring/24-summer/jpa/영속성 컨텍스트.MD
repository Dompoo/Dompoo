* 영속성 컨텍스트는 JPA의 핵심이며, 제대로 이해해야 JPA를 안다고 할 수 있다.
### EntityManagerFactory
* EntityManagerFactory는 애플리케이션 실행시에 단 한번 생성된다.
* EntityManager를 생성하는 역할을 한다.

### EntityManager
* EntityManager는 매 요청마다 생성/삭제된다.
* 정보를 DB가 아니라 영속성 컨텍스트에 저장한다.
* EntityManager를 통해서 영속성 컨텍스트에 접근할 수 있다.

### 영속성 컨텍스트
* 엔티티를 영구 저장하는 환경이라는 의미
* EntityManager와 1대1로 생성된다.
* 매 요청이 시작될 때 생성되고 종료될 때 삭제된다.

### 영속성 컨텍스트의 생명주기
* **비영속** : 영속성 컨텍스트와 상관없는 새로운 상태
  * Java 코드 그 자체, 객체만 생성한 상태이다.
* **영속** : 영속성 컨텍스트에 의해 관리되는 상태
  * EntityManager.persist()를 통해서 영속성 컨텍스트에 저장한 상태이다.
  * DB에 저장된 상태가 아니다. 영속성 컨텍스트(1차 캐시)에만 저장된 상태이다.
* **준영속** : 영속상태에서 벗어나 분리된 상태
  * EntityManager.detach()
* **삭제** : 삭제된 상태
  * EntityManager.remove()

### 영속성 컨텍스트의 역할
* **1차 캐시**
  * DB와 애 플리케이션 사이의 1차 캐시 역할을 한다.
  * 1차 캐시는 @Id-Entity-스냅샷 의 매핑정보를 저장해놓는다.
    * 조회시 DB가 아니라 1차 캐시를 찾아서 조회하게 된다.
    * 1차 캐시에 있다면 해당 정보를 반환한다.
    * 1차 캐시에 없다면 DB에서 조회한 후 1차 캐시에 저장하고 반환한다.
* **동일성 보장**
  * 기본적으로 1차 캐시에서 조회하기 때문에 얻는 이점이다.
  * 1차 캐시에서 @Id를 기준으로 조회된 Entity는  
* **쓰기 지연**
  * EntityManager.persist()만으로는 Insert 쿼리를 바로 날리지 않는다.
  * 영속성 컨텍스트의 쓰기 지연 SQL 저장소에 저장해두다가 트랜잭션이 커밋되는 시점에 한번에 날린다.
* **변경 감지**
  * 자바컬렉션처럼 객체를 다룰 수 있기 위한 기술이다.
  * 조회한 엔티티의 값을 변경 후, EntityManager.persist()를 할 필요가 없다.
  * 매커니즘
    * 1차 캐시의 스냅샷에는 영속성 컨텍스트에 처음 들어온 엔티티의 정보를 넣어놓는다.
    * 조회한 영속 엔티티의 값이 변경되면, 이는 스냅샷과 불일치하게 된다.
    * 커밋 시점에 EntityManager.flush()가 호출된다.
    * 1차 캐시 내부, 스냅샷과 엔티티를 비교한다.
    * 불일치를 확인하면 해당 엔티티에 대해서 Update 쿼리를 날린다.
  * Update 뿐만 아니라 삭제도 같은 매커니즘으로 작동한다.