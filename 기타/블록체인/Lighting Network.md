라이트닝 네트워크는 비트코인 메인 체인의 느린 거래 속도와 높은 수수료를 해결하기 위해 탄생하였다. 라이트닝 네트워크를 통해 `smart contract`가 가능하다.
1. P2P로 양방향 결제 채널을 생성한다. 
2. 결제 채널을 생성한 내용의 트랜잭션을 비트코인 메인 체인에 기록한다.
3. 첫번째 트랜잭션 이후로 여러 트랜잭션들을 쌓는다.
4. 거래가 끝난다면 가장 마지막 트랜잭션만을 비트코인 메인 체인에 기록한다.
![[Pasted image 20241206200832.png]]
- 이렇게 첫번째 커밋 이후에 일어나는 off-chain 커밋들은 블록체인에 기록되지 않는다.
- 처음에 넣은 양(140000) 보다 더 많게 송금할 수는 없으므로, 이를 channel capacity라고 한다.
- 하지만 계속 왔다갔다 하면서 flow 자체는 140000보다 많이질 수 있다.


![[Pasted image 20241206201123.png]]
각 트랜잭션은 이렇게 생겼다.
- 양쪽의 트랜잭션은 commitmet의 순서는 같지만, output의 순서가 다르다.
- 처음 output은 일정 금액을 3일 후에 자신에게 보내거나, 또는 remote key를 제시한 경우 곧바로 remote(상대방)에 보낼 수 있다.
	- 3일이 지나면 60000만은 나에게, 80000은 상대방에게
	- 3일 전에 remote key가 제출되면 60000과 80000이 모두 상대방에게
- 이를 통해 상대방은 cheating을 감지한 즉시 모든 돈을 자신에게 향하게 만들 수 있다. -> 응징을 통해 사기를 막는다.
### Commitmet의 장점
- 상대방이 비협조적이라면, 마지막 commitment를 뿌리고 채널을 닫아버릴 수 있다.
- 다른 참여자가 자신에게 유리한 commitment만 뿌린다면, revoke key를 통해 모든 돈을 다 챙길 수 있다. (응징)
### Lighting Network에 트랜잭션을 만드는 방법
- 각 트랜잭션은 상대방의 서명이 필요하다. 따라서 현재 트랜잭션에 대해 서명을 제공해야 한다.
- 이전 트랜잭션을 사용할 수 없도록 revoke key를 제공한다.
	- 만약 해당 트랜잭션이 블록체인에 포함되면, 일정 블록 개수가 append 되기 전에 revoke key를 통해 그대로 전부 가져올 수 있다. (응징)
	- 이는 timelock 덕분에 가능하다. timelock 안에 이상 트랜잭션이 블록체인에 포함된 것을 감지할 수만 있다면 응징할 수 있는 것이다.
![[Pasted image 20241206214152.png]]
## Payments Channels
- Channel로 연결되지 않은 상대방과도 거래할 수 있다.
- 다른 노드들을 통하여 연결된다.
	- 이때 각 노드들은 일정 수수료를 받는다.
- 한 노드가 '내 노드를 중간 노드로 사용해도 좋아'라고 말하는 것을 `Announcing Channel`이라고 한다.
	- 이 프로토콜을 `가십 프로토콜`이라고 부른다.
![[Pasted image 20241207190515.png]]
## Invoice
- Lighting Network에서의 암호화폐 지불을 위한 방법이다.
- 수취인 공개키, 지불 금액 등을 포함한 값을 `Base58` 등으로 인코딩하여 만든다.
- `invoice`는 오프라인을 통해 전달되며, 받은 사람은 이 코드를 통해 암호화폐를 지불할 수 있다.
### 생성
- Bob은 무작위 수 r을 정한다.
- SHA256 해시한다. H = SHA256(r)
- 추가적인 메타데이터를 넣는다.
	- 짧은 설명
	- rounting hints : invocies의 라우팅을 만들기 위해 사용
	- expiry date : 지불 후에 invocies의 r이 다시 free 해질 수 있도록 사용
- 이를 전파한다.
### Goship Protocol
#### P2P 가십 프로토콜을 통해 채널 정보를 통신한다.
1. 채널을 오픈한 노드는 `channel_announcement` 메시지를 피어들에게 전송한다.
2. 각 피어는 수신한 채널 정보를 검증한다.
3. 검증 후에 자신의 피어에게 메시지를 그대로 전달한다.
4. 이렇게 네트워크 상에서 채널 정보가 확산된다.
#### 가십 프로토콜을 통해 메타데이터를 송수신할 수 있다.
- 이 메타데이터를 통해 채널의 현재 상태를 제공함으로써, 네트워크 내부에서 라우팅 결정을 돕는다. (최적화)
- `channel_update` 메시지를 통해 공유된다.
- 과도한 통신을 방지하기 위해 채널당 하루에 약 4회만 메시지 전파된다.
#### 도전과제
- 가십 네트워크에서는 채널의 총 용량은 전파하지만, 상세한 잔액 분포는 전파하지 않는다.
	- 실제로 전송 가능한 암호화폐는 로컬 잔액 분포만큼만 가능하다.
- 하지만 여기에는 이유가 있다.
	- 프라이버시 보호
	- 확장성 : Lighting Network의 지불 규모를 확장하기 위함
	- 네트워크 동적성 : 실시간으로 바뀌는 네트워크의 상황을 계속 업데이트 하는 것은 효율도 낮고 의미가 X
#### PathFinding
- 지불 출발점에서 목적지까지의 경로를 찾는 과정이다.
- 해당 경로를 통해 실제 지불이 이루어지는 과정은 `Routing`이라고 부른다.
- PathFinding은 `발신자 기반 경로 찾기` 방법으로 한다.
	- 지불 발신자가 직접 네트워크를 통해 목적지까지의 경로를 찾는다.
	- 발신자가 전체 경로를 계산하고 결정한다.
- Routing은 `양파 라우팅` 방법으로 한다.
	- 경로의 각 요소들이 양파의 층처럼 겹겹이 암호화된다.
	- 각 노드는 자신의 계층만 해독할 수 있다.
	- 이를 통해 높은 수준의 프라이버시와 보안을 제공한다.
### 공정성
Lighting Network의 공정성을 지키는 3가지 키워드가 있다.
- 무신뢰성
	- 참여자들은 제 3자를 신뢰할 필요가 없다.
	- 단지 프로토콜을 신뢰하기만 하면 된다. 프로토콜이 부정행위를 막는다.
- 원자성
	- 모든 지불은 온전히 실행되거나 온전히 실패된다.
	- 이 덕분에 중개자들이 Payment를 받고 다음 단계로 전달하지 않는 상황을 막는다.
- 다중 홉 보안
	- 단일 채널 뿐만 아니라, 여러 채널을 통과하는 Payment에 대해서도 똑같은 공정성을 제공한다.
![[Pasted image 20241207194148.png]]
- HTLC(Hash Time-Locked Contract)에 의해서도 공정성을 제공받는다.
	1. A가 D에게 지불하고 싶다고 하자.
	2. A가 D에게 지불 요청을 한다.
	3. D는 r을 생성하고 SHA256(r)과 메타데이터를 전달한다. (Invoice 전달)
	4. A는 그것을 받아서 지불한다.
	5. 이 지불은 해쉬에 의해 r을 알 수 없으므로, 검증은 가능하지만 뚫기는 어렵다.
![[Pasted image 20241207194314.png]]
- 중간 라우팅을 담당한 Bob은 `OP_SHA256 <H> OP_EQUAL` 를 전달한다.
- 모든 과정이 끝나고, 나중에 R을 알게 되면 `<R> OP_SHA256 <H> OP_EQUAL`를 통해 스크립트를 풀 수 있다.
- 즉, 모든 과정이 끝나야(R이 전파되어야) 100사토시의 이득을 볼 수 있다.
	- 이때, R을 남에게도 전파하지 않으면 HTLC를 사용할 수 없다. (시간이 지나면 전체 HTLC가 취소된다.)
	- 따라서 Bob이 자기만 R을 사용하고 남에게 전파하지 않는 행위가 불가능하다. (원자성)
- 따라서 R이 공개되어 전부 수수료를 받고 성공하거나, R이 공개되지 않아서 전부 수수료를 받지 않고 실패하는 두가지 결론밖에 나오지 않는다.
#### 서명 바인딩
- 기존 HTLC와 방법이 조금 다르다.
	- 기존 : `OP_SHA256 <H> OP_EQUAL`
	- 새로운 : `OP_SHA256 <H> OP_EQUALVERIFY <Bob's Pub> OP_CHECKSIG`
- 이것을 풀려면 Bob의 서명이 필요하다.
	- `<Bob's Sig> <R>`
- 이렇게 하여 HTLC의 보안성을 높이고, 무결성을 보장할 수 있다.
	- `<Bob's Sig> <R> OP_SHA256 <H> OP_EQUALVERIFY <Bob's Pub> OP_CHECKSIG`
#### 실패 방법
- 중간 라우팅이 끊어지거나 오프라인이 된 경우 우아하게 실패할 필요가 있다.
- 크게 두가지 방법을 통해 실패한다.
	- 협력적 실패
		- 경로의 모든 참여자가 HTLC 출력을 제거한다.
	- TimeLock 환불
		- 모든 HTLC 스크립트에 타임락 환불 내용을 추가한다. (IF ELIF로 추가됨)
		- `OP_DROP <cltv_expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP OP_CHECKSIG`
- TimeLock 환불에서, TimeLock 값을 고정적으로 사용하지 않는다.
	- 지불 실패시 순서있는 되감기를 위하여 점점 줄어들도록 설계한다.
		- 첫번째 라우팅(Alice) : 현재 높이 + 500블록
		- 두번째 라우팅(Bob) : 현재 높이 + 450블록
		- ...
	- 이를 통해 Bob이 Alice보다 더 빠르게 환불받을 수 있고, Alice에게 환불해줄 때의 Race Condition을 막는다.
		- 돈이 역으로 파도처럼 돌아옴
	- 쉽게 말해, Invoice를 만든 노드에 가까운 라우팅부터 환불받는다.
## 비트코인 vs  Lighting Network
### 주소
- BTC
	- 재사용 가능한 주소
	- 주소는 만료되지 않음
	- 동일 주소로 여러 번 수취 가능
	- 고정 주소로 다양한 금액 수신
- LN
	- 일회용 인보이스
	- 각 인보이스는 특정 금액에 대해서만 유효
	- 인보이스마다 만료 시간 존재
	- 각 지불마다 새로운 인보이스 생성 필요
### 지불 프로세스
- BTC
	- 비트코인 주소 수령 (QR 코드, 메시지 등)
	- 주소로 자유롭게 송금
	- 비트코인은 지불하기 위해 UTXO를 선택한다.
- LN
	- 수취인이 특정 금액의 인보이스 생성
	- 인보이스를 발신자에게 전달
	- 발신자는 인보이스 텍스트나 QR 코드로 지불
	- 인보이스는 지불하기 위해 채널과 경로를 선택한다.
### 잔돈
- BTC
	- 잔돈에 대한 다른 트랜잭션이 생긴다.
	- 온체인에서 처리하므로 느리고 수수료가 높다.
- LN
	- 처음에는 잔돈 없이 채널 잔액만 업데이트한다.
	- 오프체인에서 이루어지므로 효율적이다.
### 비용
- BTC
	- 채굴자에게 Fee를 낸다.
	- 이 비용은 트랜잭션의 크기와, 얼마나 내 트랜잭션이 체인에 포함되기를 원하는지 등에 따라 달라진다.
		- 큰 비용에 대해서 비교적으로 유리하다.
	- 이 비용은 트랜잭션 발행자가 제시하므로, 비용이 클수록 선택되기 쉽다.
- LN
	- 중간 노드들에게 비용을 낸다.
	- 고정 수수료 : 정해진 값의 수수료를 낸다.
	- 가변 수수료 : 움직이는 자금의 양에 따라 수수료를 낸다.
	- 이 수수료는 중간 노드가 정하므로, 더 낮은 수수료를 제시하고, 용량이 큰 중간 노드가 선택되기 쉽다.
		- 작은 비용에 대해서 비교적으로 유리하다.
### 접근성
- BTC
	- 모든 트랜잭션은 public 하다.
- LN
	- 각 인보이스는 거의 private하다.
	- 일부 중간 노드들만 트랜잭션을 안다.
### 확정성
- BTC
	- 트랜잭션이 블록체인에 포함되어야 확정된다.
	- 이런 과정이 매 결제마다 필요하다.
- LN
	- 처음과 끝에만 확정되면 된다.
	- 중간의 결제들은 즉각적으로 수용된다.
### 결제한도
- BTC
	- 자신이 낼 수 있는 최대 용량으로 낼 수 있다.
- LN
	- 중간 노드들의 용량도 고려하여 내야 한다.
	- 예를들어, 내가 0.3을 내고 싶다면, 경로상의 모든 노드가 0.3의 용량을 갖고 있어야 한다.
### 동기성
- BTC
	- 트랜잭션을 만들고 나면, 무슨 노드가 온라인이고 오프라인인지 알 필요가 없다.
	- 따라서 수동적이고 비동기적이다.
- LN
	- 중간 노드들이 온라인인지 오프라인인지 알 필요가 있다.
	- 능동적이고 동기적이다.
### 단위
- BTC
	- 큰 금액 위주로 거래가 이루어지므로 satoshi를 쓴다.
- LN
	- 작은 금액 위주로 거래가 이루어지므로 milisatoshi를 쓴다.
### 공통점
- 둘 다 비트코인 기반 화폐를 쓴다.
- 둘 다 비가역적이다. 한번 만들어지면 되돌릴 수 없다. (뭔가를 변경하려면 그 위에 추가해야 한다.)
- 둘 다 제 3자를 믿을 필요 없이 메커니즘을 믿으면 된다.
- 둘 다 권한이 필요없다. 누구나 들어와서 참여할 수 있다.
- 둘 다 오픈소스이다.